# ðŸŽ¯ Enhanced Inference Server - Complete Architecture with Refined Phases & State Machine

## ðŸ“‹ Updated InferencePhase Enum

```java
package tech.kayys.golek.inference.kernel.pipeline;

/**
 * Comprehensive ordered phases of inference execution.
 * Each phase represents a distinct stage with specific responsibilities.
 * Plugins are bound to specific phases.
 */
public enum InferencePhase {
    
    /**
     * Phase 1: Pre-validation checks
     * - Request structure validation
     * - Basic sanity checks
     * - Early rejection of malformed requests
     */
    PRE_VALIDATE(1, "Pre-Validation"),
    
    /**
     * Phase 2: Deep validation
     * - Schema validation (JSON Schema)
     * - Content safety checks
     * - Input format verification
     * - Model compatibility checks
     */
    VALIDATE(2, "Validation"),
    
    /**
     * Phase 3: Authorization & access control
     * - Tenant verification
     * - Model access permissions
     * - Feature flag checks
     * - Quota verification
     */
    AUTHORIZE(3, "Authorization"),
    
    /**
     * Phase 4: Intelligent routing & provider selection
     * - Model-to-provider mapping
     * - Multi-factor scoring
     * - Load balancing
     * - Availability checks
     */
    ROUTE(4, "Routing"),
    
    /**
     * Phase 5: Request transformation & enrichment
     * - Prompt templating
     * - Context injection
     * - Parameter normalization
     * - Request mutation
     */
    PRE_PROCESSING(5, "Pre-Processing"),
    
    /**
     * Phase 6: Actual provider dispatch
     * - Provider invocation
     * - Streaming/batch execution
     * - Circuit breaker protection
     * - Fallback handling
     */
    PROVIDER_DISPATCH(6, "Provider Dispatch"),
    
    /**
     * Phase 7: Response post-processing
     * - Output validation
     * - Format normalization
     * - Metadata enrichment
     * - Content moderation
     */
    POST_PROCESSING(7, "Post-Processing"),
    
    /**
     * Phase 8: Audit logging
     * - Event recording
     * - Provenance tracking
     * - Compliance logging
     * - Immutable audit trail
     */
    AUDIT(8, "Audit"),
    
    /**
     * Phase 9: Observability & metrics
     * - Metrics emission
     * - Trace completion
     * - Performance tracking
     * - Cost accounting
     */
    OBSERVABILITY(9, "Observability"),
    
    /**
     * Phase 10: Resource cleanup
     * - Cache invalidation
     * - Connection release
     * - Quota release
     * - Temporary resource cleanup
     */
    CLEANUP(10, "Cleanup");

    private final int order;
    private final String displayName;

    InferencePhase(int order, String displayName) {
        this.order = order;
        this.displayName = displayName;
    }

    public int getOrder() {
        return order;
    }

    public String getDisplayName() {
        return displayName;
    }

    /**
     * Get phases in execution order
     */
    public static List<InferencePhase> ordered() {
        return Arrays.stream(values())
            .sorted(Comparator.comparing(InferencePhase::getOrder))
            .toList();
    }

    /**
     * Check if this phase is critical (execution cannot proceed if it fails)
     */
    public boolean isCritical() {
        return this == PRE_VALIDATE || 
               this == VALIDATE || 
               this == AUTHORIZE ||
               this == PROVIDER_DISPATCH;
    }

    /**
     * Check if this phase can be retried
     */
    public boolean isRetryable() {
        return this == ROUTE || 
               this == PROVIDER_DISPATCH;
    }

    /**
     * Check if this phase is idempotent
     */
    public boolean isIdempotent() {
        return this != PROVIDER_DISPATCH;
    }
}
```

---

## ðŸ”„ Execution State Machine

### ExecutionStatus (Canonical States)

```java
package tech.kayys.golek.inference.kernel.execution;

/**
 * Canonical execution states for inference requests.
 * These states are the single source of truth.
 */
public enum ExecutionStatus {

    /**
     * Request created, not yet started
     */
    CREATED("Created", false, false),
    
    /**
     * Actively executing through phases
     */
    RUNNING("Running", false, false),
    
    /**
     * Waiting for external event (HITL, async callback)
     */
    WAITING("Waiting", false, false),
    
    /**
     * Paused by policy or manual intervention
     */
    SUSPENDED("Suspended", false, false),
    
    /**
     * In retry backoff period
     */
    RETRYING("Retrying", false, false),
    
    /**
     * Successfully completed
     */
    COMPLETED("Completed", true, false),
    
    /**
     * Terminal failure (exhausted retries)
     */
    FAILED("Failed", true, true),
    
    /**
     * Rollback/compensation completed
     */
    COMPENSATED("Compensated", true, false),
    
    /**
     * Cancelled by user/system
     */
    CANCELLED("Cancelled", true, false);

    private final String displayName;
    private final boolean terminal;
    private final boolean error;

    ExecutionStatus(String displayName, boolean terminal, boolean error) {
        this.displayName = displayName;
        this.terminal = terminal;
        this.error = error;
    }

    public String getDisplayName() {
        return displayName;
    }

    public boolean isTerminal() {
        return terminal;
    }

    public boolean isError() {
        return error;
    }

    public boolean isActive() {
        return !terminal;
    }
}
```

### ExecutionSignal (State Transition Triggers)

```java
package tech.kayys.golek.inference.kernel.execution;

/**
 * Signals that trigger state transitions.
 * These are events, not states.
 */
public enum ExecutionSignal {

    /**
     * Execution started
     */
    START,
    
    /**
     * Phase completed successfully
     */
    PHASE_SUCCESS,
    
    /**
     * Phase failed
     */
    PHASE_FAILURE,
    
    /**
     * All phases completed
     */
    EXECUTION_SUCCESS,
    
    /**
     * Execution failed
     */
    EXECUTION_FAILURE,
    
    /**
     * Retry limit exhausted
     */
    RETRY_EXHAUSTED,
    
    /**
     * External wait requested (HITL, async)
     */
    WAIT_REQUESTED,
    
    /**
     * External approval received
     */
    APPROVED,
    
    /**
     * External rejection received
     */
    REJECTED,
    
    /**
     * Compensation triggered
     */
    COMPENSATE,
    
    /**
     * Compensation completed
     */
    COMPENSATION_DONE,
    
    /**
     * Cancellation requested
     */
    CANCEL,
    
    /**
     * Resume from suspended state
     */
    RESUME;
}
```

### ExecutionStateMachine

```java
package tech.kayys.golek.inference.kernel.execution;

/**
 * Deterministic state machine for execution lifecycle.
 * Pure function: (current state, signal) -> next state
 */
public interface ExecutionStateMachine {

    /**
     * Compute next state based on current state and signal
     */
    ExecutionStatus next(
        ExecutionStatus current,
        ExecutionSignal signal
    );

    /**
     * Validate if transition is allowed
     */
    boolean isTransitionAllowed(
        ExecutionStatus from,
        ExecutionStatus to
    );
}
```

### DefaultExecutionStateMachine

```java
package tech.kayys.golek.inference.kernel.execution;

import jakarta.enterprise.context.ApplicationScoped;
import java.util.Map;
import java.util.Set;

/**
 * Default implementation of execution state machine.
 * Enforces valid state transitions.
 */
@ApplicationScoped
public class DefaultExecutionStateMachine implements ExecutionStateMachine {

    // Valid transitions map
    private static final Map<ExecutionStatus, Set<ExecutionStatus>> ALLOWED_TRANSITIONS = Map.of(
        ExecutionStatus.CREATED, Set.of(ExecutionStatus.RUNNING, ExecutionStatus.CANCELLED),
        ExecutionStatus.RUNNING, Set.of(ExecutionStatus.WAITING, ExecutionStatus.RETRYING, 
                                       ExecutionStatus.COMPLETED, ExecutionStatus.FAILED, 
                                       ExecutionStatus.SUSPENDED, ExecutionStatus.CANCELLED),
        ExecutionStatus.WAITING, Set.of(ExecutionStatus.RUNNING, ExecutionStatus.FAILED, 
                                       ExecutionStatus.CANCELLED),
        ExecutionStatus.SUSPENDED, Set.of(ExecutionStatus.RUNNING, ExecutionStatus.CANCELLED),
        ExecutionStatus.RETRYING, Set.of(ExecutionStatus.RUNNING, ExecutionStatus.FAILED)
    );

    @Override
    public ExecutionStatus next(
        ExecutionStatus current,
        ExecutionSignal signal
    ) {
        ExecutionStatus nextState = computeNextState(current, signal);
        
        if (!isTransitionAllowed(current, nextState)) {
            throw new IllegalStateTransitionException(
                "Invalid transition from " + current + " to " + nextState
            );
        }
        
        return nextState;
    }

    private ExecutionStatus computeNextState(
        ExecutionStatus current,
        ExecutionSignal signal
    ) {
        return switch (current) {

            case CREATED -> switch (signal) {
                case START -> ExecutionStatus.RUNNING;
                case CANCEL -> ExecutionStatus.CANCELLED;
                default -> current;
            };

            case RUNNING -> switch (signal) {
                case EXECUTION_SUCCESS -> ExecutionStatus.COMPLETED;
                case PHASE_FAILURE, EXECUTION_FAILURE -> ExecutionStatus.RETRYING;
                case WAIT_REQUESTED -> ExecutionStatus.WAITING;
                case CANCEL -> ExecutionStatus.CANCELLED;
                case COMPENSATE -> ExecutionStatus.COMPENSATED;
                default -> current;
            };

            case RETRYING -> switch (signal) {
                case START, RESUME -> ExecutionStatus.RUNNING;
                case RETRY_EXHAUSTED -> ExecutionStatus.FAILED;
                case CANCEL -> ExecutionStatus.CANCELLED;
                default -> current;
            };

            case WAITING -> switch (signal) {
                case APPROVED, RESUME -> ExecutionStatus.RUNNING;
                case REJECTED -> ExecutionStatus.FAILED;
                case CANCEL -> ExecutionStatus.CANCELLED;
                default -> current;
            };

            case SUSPENDED -> switch (signal) {
                case RESUME -> ExecutionStatus.RUNNING;
                case CANCEL -> ExecutionStatus.CANCELLED;
                default -> current;
            };

            case COMPENSATED -> switch (signal) {
                case COMPENSATION_DONE -> ExecutionStatus.COMPLETED;
                default -> current;
            };

            // Terminal states
            case COMPLETED, FAILED, CANCELLED -> current;
        };
    }

    @Override
    public boolean isTransitionAllowed(
        ExecutionStatus from,
        ExecutionStatus to
    ) {
        if (from == to) {
            return true; // Self-transition always allowed
        }
        
        Set<ExecutionStatus> allowed = ALLOWED_TRANSITIONS.get(from);
        return allowed != null && allowed.contains(to);
    }
}
```

---

## ðŸŽ¯ ExecutionToken (Single Source of Truth)

```java
package tech.kayys.golek.inference.kernel.execution;

import java.time.Instant;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Immutable execution token representing the current state
 * of an inference request execution.
 * 
 * This is the single source of truth for execution state.
 * Serializable, persistable, and rehydration-safe.
 */
public final class ExecutionToken {

    private final String executionId;
    private final String requestId;
    private final ExecutionStatus status;
    private final InferencePhase currentPhase;
    private final int attempt;
    private final Instant createdAt;
    private final Instant lastUpdated;
    
    // Execution variables (mutable container for immutable token)
    private final Map<String, Object> variables;
    
    // Execution metadata
    private final Map<String, Object> metadata;

    private ExecutionToken(Builder builder) {
        this.executionId = builder.executionId;
        this.requestId = builder.requestId;
        this.status = builder.status;
        this.currentPhase = builder.currentPhase;
        this.attempt = builder.attempt;
        this.createdAt = builder.createdAt;
        this.lastUpdated = builder.lastUpdated;
        this.variables = new ConcurrentHashMap<>(builder.variables);
        this.metadata = new ConcurrentHashMap<>(builder.metadata);
    }

    // Getters
    public String getExecutionId() { return executionId; }
    public String getRequestId() { return requestId; }
    public ExecutionStatus getStatus() { return status; }
    public InferencePhase getCurrentPhase() { return currentPhase; }
    public int getAttempt() { return attempt; }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getLastUpdated() { return lastUpdated; }
    public Map<String, Object> getVariables() { return new ConcurrentHashMap<>(variables); }
    public Map<String, Object> getMetadata() { return new ConcurrentHashMap<>(metadata); }

    /**
     * Create new token with updated status
     */
    public ExecutionToken withStatus(ExecutionStatus newStatus) {
        return toBuilder()
            .status(newStatus)
            .lastUpdated(Instant.now())
            .build();
    }

    /**
     * Create new token with updated phase
     */
    public ExecutionToken withPhase(InferencePhase newPhase) {
        return toBuilder()
            .currentPhase(newPhase)
            .lastUpdated(Instant.now())
            .build();
    }

    /**
     * Create new token with incremented attempt
     */
    public ExecutionToken withNextAttempt() {
        return toBuilder()
            .attempt(attempt + 1)
            .lastUpdated(Instant.now())
            .build();
    }

    /**
     * Create new token with updated variable
     */
    public ExecutionToken withVariable(String key, Object value) {
        Map<String, Object> newVars = new ConcurrentHashMap<>(variables);
        newVars.put(key, value);
        return toBuilder()
            .variables(newVars)
            .lastUpdated(Instant.now())
            .build();
    }

    public static Builder builder() {
        return new Builder();
    }

    public Builder toBuilder() {
        return new Builder()
            .executionId(executionId)
            .requestId(requestId)
            .status(status)
            .currentPhase(currentPhase)
            .attempt(attempt)
            .createdAt(createdAt)
            .lastUpdated(lastUpdated)
            .variables(variables)
            .metadata(metadata);
    }

    public static class Builder {
        private String executionId;
        private String requestId;
        private ExecutionStatus status = ExecutionStatus.CREATED;
        private InferencePhase currentPhase = InferencePhase.PRE_VALIDATE;
        private int attempt = 0;
        private Instant createdAt = Instant.now();
        private Instant lastUpdated = Instant.now();
        private Map<String, Object> variables = new ConcurrentHashMap<>();
        private Map<String, Object> metadata = new ConcurrentHashMap<>();

        public Builder executionId(String executionId) {
            this.executionId = executionId;
            return this;
        }

        public Builder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        public Builder status(ExecutionStatus status) {
            this.status = status;
            return this;
        }

        public Builder currentPhase(InferencePhase currentPhase) {
            this.currentPhase = currentPhase;
            return this;
        }

        public Builder attempt(int attempt) {
            this.attempt = attempt;
            return this;
        }

        public Builder createdAt(Instant createdAt) {
            this.createdAt = createdAt;
            return this;
        }

        public Builder lastUpdated(Instant lastUpdated) {
            this.lastUpdated = lastUpdated;
            return this;
        }

        public Builder variables(Map<String, Object> variables) {
            this.variables = new ConcurrentHashMap<>(variables);
            return this;
        }

        public Builder variable(String key, Object value) {
            this.variables.put(key, value);
            return this;
        }

        public Builder metadata(Map<String, Object> metadata) {
            this.metadata = new ConcurrentHashMap<>(metadata);
            return this;
        }

        public Builder metadataEntry(String key, Object value) {
            this.metadata.put(key, value);
            return this;
        }

        public ExecutionToken build() {
            if (executionId == null) {
                executionId = UUID.randomUUID().toString();
            }
            if (requestId == null) {
                throw new IllegalStateException("requestId is required");
            }
            return new ExecutionToken(this);
        }
    }
}
```

---

## ðŸ”§ ExecutionContext (Request-Scoped State)

```java
package tech.kayys.golek.inference.kernel.execution;

import tech.kayys.golek.inference.kernel.engine.EngineContext;
import tech.kayys.golek.inference.api.TenantContext;

/**
 * Mutable execution context for a single inference request.
 * Provides access to execution token, variables, and engine context.
 */
public interface ExecutionContext {

    /**
     * Get engine context (global state)
     */
    EngineContext engine();

    /**
     * Get current execution token (immutable snapshot)
     */
    ExecutionToken token();

    /**
     * Get tenant context
     */
    TenantContext tenantContext();

    /**
     * Update execution status (creates new token)
     */
    void updateStatus(ExecutionStatus status);

    /**
     * Update current phase (creates new token)
     */
    void updatePhase(InferencePhase phase);

    /**
     * Increment retry attempt
     */
    void incrementAttempt();

    /**
     * Get execution variables (mutable view)
     */
    Map<String, Object> variables();

    /**
     * Put variable
     */
    void putVariable(String key, Object value);

    /**
     * Get variable
     */
    <T> Optional<T> getVariable(String key, Class<T> type);

    /**
     * Get metadata
     */
    Map<String, Object> metadata();

    /**
     * Put metadata
     */
    void putMetadata(String key, Object value);

    /**
     * Replace entire token (for state restoration)
     */
    void replaceToken(ExecutionToken newToken);
}
```

### DefaultExecutionContext

```java
package tech.kayys.golek.inference.kernel.execution;

import tech.kayys.golek.inference.kernel.engine.EngineContext;
import tech.kayys.golek.inference.api.TenantContext;

import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Default implementation of execution context.
 */
public class DefaultExecutionContext implements ExecutionContext {

    private final EngineContext engineContext;
    private final TenantContext tenantContext;
    private final AtomicReference<ExecutionToken> tokenRef;

    public DefaultExecutionContext(
        EngineContext engineContext,
        TenantContext tenantContext,
        ExecutionToken initialToken
    ) {
        this.engineContext = engineContext;
        this.tenantContext = tenantContext;
        this.tokenRef = new AtomicReference<>(initialToken);
    }

    @Override
    public EngineContext engine() {
        return engineContext;
    }

    @Override
    public ExecutionToken token() {
        return tokenRef.get();
    }

    @Override
    public TenantContext tenantContext() {
        return tenantContext;
    }

    @Override
    public void updateStatus(ExecutionStatus status) {
        tokenRef.updateAndGet(token -> token.withStatus(status));
    }

    @Override
    public void updatePhase(InferencePhase phase) {
        tokenRef.updateAndGet(token -> token.withPhase(phase));
    }

    @Override
    public void incrementAttempt() {
        tokenRef.updateAndGet(ExecutionToken::withNextAttempt);
    }

    @Override
    public Map<String, Object> variables() {
        return token().getVariables();
    }

    @Override
    public void putVariable(String key, Object value) {
        tokenRef.updateAndGet(token -> token.withVariable(key, value));
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> Optional<T> getVariable(String key, Class<T> type) {
        Object value = variables().get(key);
        if (value == null) {
            return Optional.empty();
        }
        if (type.isInstance(value)) {
            return Optional.of((T) value);
        }
        return Optional.empty();
    }

    @Override
    public Map<String, Object> metadata() {
        return token().getMetadata();
    }

    @Override
    public void putMetadata(String key, Object value) {
        Map<String, Object> meta = token().getMetadata();
        meta.put(key, value);
    }

    @Override
    public void replaceToken(ExecutionToken newToken) {
        tokenRef.set(newToken);
    }
}
```

---

## ðŸŽ­ InferenceEngine with State Machine Integration

```java
package tech.kayys.golek.inference.kernel.engine;

```

---

## ðŸ“Š Updated Pipeline Execution

```java
package tech.kayys.golek.inference.kernel.pipeline;

import tech.kayys.golek.inference.kernel.execution.*;
import tech.kayys.golek.inference.kernel.plugin.*;
import io.smallrye.mutiny.Uni;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

/**
 * Enhanced pipeline with phase-by-phase state tracking.
 */
@ApplicationScoped
public class DefaultInferencePipeline implements InferencePipeline {

    @Inject
    PluginRegistry pluginRegistry;

    @Override
    public Uni<ExecutionContext> execute(ExecutionContext context) {
        List<InferencePhase> phases = InferencePhase.ordered();

        Uni<ExecutionContext> pipeline = Uni.createFrom().item(context);

        for (InferencePhase phase : phases) {
            pipeline = pipeline.chain(ctx -> executePhase(ctx, phase));
        }

        return pipeline;
    }

    private Uni<ExecutionContext> executePhase(
        ExecutionContext context,
        InferencePhase phase
    ) {
        // Update current phase
        context.updatePhase(phase);

        // Get plugins for this phase
        List<InferencePhasePlugin> plugins = pluginRegistry
            .byPhase(phase)
            .stream()
            .filter(p -> p.shouldExecute(context))
            .sorted(Comparator.comparing(Plugin::order))
            .toList();

        // Execute plugins sequentially
        Uni<Void> pluginChain = Uni.createFrom().voidItem();

        for (InferencePhasePlugin plugin : plugins) {
            pluginChain = pluginChain.chain(() -> 
                plugin.execute(context, context.engine())
            );
        }

        return pluginChain
            .onItem().transform(v -> context)
            .onFailure().invoke(error -> {
                // Log phase failure
                context.putMetadata("failedPhase", phase.name());
                context.putMetadata("error", error.getMessage());
            });
    }
}
```

---

## ðŸŽ¯ Summary of State Machine Integration

### âœ… What This Delivers

1. **Deterministic Execution**
   - Pure state machine: `(state, signal) -> next state`
   - No ambiguous transitions
   - Fully testable state logic

2. **Resumable Execution**
   - Execution token is serializable
   - Can persist and rehydrate
   - Supports long-running operations

3. **Retry-Safe**
   - State machine handles retry transitions
   - Exponential backoff built-in
   - Idempotent phase execution

4. **Human-Aware**
   - `WAITING` state for HITL
   - `SUSPENDED` for policy holds
   - Clean approval/rejection flow

5. **Agent-Friendly**
   - Supports multi-agent negotiations
   - Async callbacks
   - Distributed execution

6. **Comprehensive Phases**
   - **PRE_VALIDATE**: Early rejection
   - **VALIDATE**: Deep validation
   - **AUTHORIZE**: Access control
   - **ROUTE**: Intelligent provider selection
   - **PRE_PROCESSING**: Request transformation
   - **PROVIDER_DISPATCH**: Actual LLM call
   - **POST_PROCESSING**: Response normalization
   - **AUDIT**: Immutable logging
   - **OBSERVABILITY**: Metrics & tracing
   - **CLEANUP**: Resource release

This architecture is now **production-grade**, **deterministic**, and **fully aligned** with both the enhanced phase model and the execution lifecycle requirements. ðŸš€