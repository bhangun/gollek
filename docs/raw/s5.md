Perfect.
We continue **exactly on the same system**, no contract changes, no renaming.

---

# âœ… STEP 5 â€” INFERENCE ORCHESTRATOR (THE EXECUTION HEART)

This is the **only component that actually runs inference**.

Everything before this step was **static**:

* Plugins
* Pipeline
* Context
* Configuration

Now we **execute**.

---

## 5.1 Responsibilities (Very Clear)

`InferenceOrchestrator` is responsible for:

1. Creating **InferenceContext**
2. Executing **InferencePipeline phases**
3. Calling **ExecutorDispatcher only once**
4. Emitting **events**
5. Handling **failures, retries, cancellation**
6. Persisting **final state**

Plugins **never** talk to executors directly.

---

## 5.2 InferenceContext (Per-Request)

```java
public interface InferenceContext {

    EngineContext engine();

    String inferenceId();

    Instant startedAt();

    TenantContext tenant();

    SecurityContext security();

    InferenceRequest request();

    InferenceResult result();

    void setResult(InferenceResult result);

    InferenceStatus status();

    void setStatus(InferenceStatus status);

    Map<String, Object> attributes();

    boolean isCancelled();
}
```

---

### DefaultInferenceContext

```java
public final class DefaultInferenceContext
        implements InferenceContext {

    private final EngineContext engine;
    private final String inferenceId;
    private final Instant startedAt;
    private final TenantContext tenant;
    private final SecurityContext security;
    private final InferenceRequest request;

    private volatile InferenceResult result;
    private volatile InferenceStatus status = InferenceStatus.CREATED;
    private final Map<String, Object> attributes = new ConcurrentHashMap<>();
    private final AtomicBoolean cancelled = new AtomicBoolean(false);

    public DefaultInferenceContext(
            EngineContext engine,
            String inferenceId,
            TenantContext tenant,
            SecurityContext security,
            InferenceRequest request
    ) {
        this.engine = engine;
        this.inferenceId = inferenceId;
        this.startedAt = Instant.now(engine.clock());
        this.tenant = tenant;
        this.security = security;
        this.request = request;
    }

    @Override public EngineContext engine() { return engine; }
    @Override public String inferenceId() { return inferenceId; }
    @Override public Instant startedAt() { return startedAt; }
    @Override public TenantContext tenant() { return tenant; }
    @Override public SecurityContext security() { return security; }
    @Override public InferenceRequest request() { return request; }
    @Override public InferenceResult result() { return result; }
    @Override public void setResult(InferenceResult result) { this.result = result; }
    @Override public InferenceStatus status() { return status; }
    @Override public void setStatus(InferenceStatus status) { this.status = status; }
    @Override public Map<String, Object> attributes() { return attributes; }
    @Override public boolean isCancelled() { return cancelled.get(); }

    public void cancel() {
        cancelled.set(true);
    }
}
```

---

## 5.3 InferencePipeline (Already Compiled)

Reminder:

```java
public interface InferencePipeline {

    void execute(InferenceContext context);
}
```

Pipeline = ordered list of `InferencePhase`.

---

## 5.4 InferenceOrchestrator (FINAL)

```java
public final class InferenceOrchestrator {

    private final EngineContext engine;
    private final InferencePipeline pipeline;

    public InferenceOrchestrator(
            EngineContext engine,
            InferencePipeline pipeline
    ) {
        this.engine = engine;
        this.pipeline = pipeline;
    }

    public InferenceResult infer(
            InferenceRequest request,
            TenantContext tenantContext
    ) {
        String inferenceId = UUID.randomUUID().toString();

        InferenceContext ctx =
                new DefaultInferenceContext(
                        engine,
                        inferenceId,
                        tenantContext,
                        engine.security(),
                        request
                );

        engine.eventPublisher().publish(
                new InferenceStartedEvent(inferenceId)
        );

        try {
            ctx.setStatus(InferenceStatus.RUNNING);

            pipeline.execute(ctx);

            ctx.setStatus(InferenceStatus.COMPLETED);

            engine.eventPublisher().publish(
                    new InferenceCompletedEvent(
                            inferenceId,
                            ctx.result()
                    )
            );

            return ctx.result();

        } catch (Exception ex) {

            ctx.setStatus(InferenceStatus.FAILED);

            engine.eventPublisher().publish(
                    new InferenceFailedEvent(
                            inferenceId,
                            ex
                    )
            );

            throw ex;

        } finally {
            engine.persistence().saveInference(ctx);
        }
    }
}
```

âœ” Single entry point
âœ” Deterministic
âœ” Plugin-driven
âœ” Executor-safe

---

## 5.5 What Happens During pipeline.execute()

Recall the phases:

```
PRE_VALIDATE
VALIDATE
AUTHORIZE
ROUTE
PRE_INFERENCE
INFERENCE        <-- ONLY HERE executor runs
POST_INFERENCE
OBSERVABILITY
CLEANUP
```

Each phase:

* Calls plugins
* Mutates `InferenceContext`
* Can short-circuit

---

## 5.6 Example: INFERENCE Phase (Executor Call)

```java
public final class InferencePhase
        implements InferencePhase {

    @Override
    public InferencePhaseType type() {
        return InferencePhaseType.INFERENCE;
    }

    @Override
    public void execute(
            InferenceContext ctx,
            EngineContext engine
    ) {
        if (ctx.isCancelled()) {
            throw new InferenceCancelledException();
        }

        ExecutorDispatcher dispatcher =
                engine.executorDispatcher();

        InferenceResult result =
                dispatcher.dispatch(
                        new InferenceCall(
                                ctx.request(),
                                ctx.tenant(),
                                ctx.security()
                        )
                );

        ctx.setResult(result);
    }
}
```

âœ” Plugins cannot bypass orchestration
âœ” Executors isolated

---

## 5.7 Failure Semantics (CRITICAL)

| Failure Type           | Behavior         |
| ---------------------- | ---------------- |
| ValidationException    | Stop immediately |
| AuthorizationException | Stop             |
| ExecutorFailure        | Retry / fallback |
| Cancelled              | Graceful stop    |
| Plugin bug             | Fail fast        |

---

## ðŸ§  STEP 5 CHECKPOINT

You now have:

| Piece              | Status |
| ------------------ | ------ |
| Plugin system      | âœ…      |
| Phases             | âœ…      |
| EngineContext      | âœ…      |
| InferenceContext   | âœ…      |
| Orchestrator       | âœ…      |
| Executor isolation | âœ…      |

This is **enterprise-grade**, **future-proof**, and **consistent**.

---

## â–¶ï¸ NEXT STEP (Step 6)

**Distributed Execution & Executor Implementations**

We will cover:

* Local vs Remote executor
* gRPC executor
* Cloud LLM providers (OpenAI / Anthropic)
* Retry & backoff
* Sandboxing

Say **â€œgo step 6â€**
