Great.
We continue **strictly from the locked model**. No renaming, no invention.

---

# ‚úÖ STEP 3 ‚Äî PLUGIN SYSTEM (FINAL, CANONICAL)

This step answers **one question only**:

> **How do we safely inject logic into the engine without breaking determinism?**

---

## 3.1 Plugin Taxonomy (LOCKED)

There are **exactly three plugin abstractions**:

```
Plugin
 ‚îî‚îÄ‚îÄ ConfigurablePlugin
       ‚îî‚îÄ‚îÄ InferencePhasePlugin
```

‚ùå No ‚ÄúInferencePlugin‚Äù
‚ùå No ‚ÄúExecutorPlugin‚Äù
‚ùå No ‚ÄúValidationPlugin‚Äù base (validation is a specialization)

Everything maps cleanly to this tree.

---

## 3.2 Plugin (ROOT)

**Purpose:**
Defines **identity, ordering, and lifecycle**.

```java
public interface Plugin {

    /**
     * Stable unique id (used for audit, config, enable/disable)
     */
    String id();

    /**
     * Lower runs earlier
     */
    int order();

    /**
     * Lifecycle hook
     */
    default void initialize(EngineContext context) {}

    /**
     * Lifecycle hook
     */
    default void shutdown() {}
}
```

### Rules

* Plugins are **long-lived**
* Initialized once per engine
* Must be thread-safe

---

## 3.3 ConfigurablePlugin

**Purpose:**
Allows **external configuration** without recompilation.

```java
public interface ConfigurablePlugin extends Plugin {

    void configure(Configuration configuration);
}
```

‚úî Configuration injected **before initialize**
‚úî Supports feature flags, quotas, thresholds

---

## 3.4 InferencePhasePlugin (CORE)

**Purpose:**
Executes logic **at a specific phase**.

```java
public interface InferencePhasePlugin extends ConfigurablePlugin {

    /**
     * Phase this plugin binds to
     */
    InferencePhase phase();

    /**
     * Execute logic for the phase
     */
    void execute(InferenceContext context, EngineContext engineContext);
}
```

‚ö†Ô∏è **Critical Rule**
Plugins:

* MAY read/write `InferenceContext`
* MAY use services from `EngineContext`
* MUST NOT call providers directly
* MUST NOT block indefinitely

---

## 3.5 Failure Semantics (ENTERPRISE GRADE)

### PluginFailureStrategy

```java
public enum PluginFailureStrategy {
    FAIL_FAST,
    CONTINUE,
    RETRY
}
```

### Optional Extension

```java
public interface FaultTolerantPlugin {

    PluginFailureStrategy failureStrategy();
}
```

Engine default:

* `FAIL_FAST` for validation
* `CONTINUE` for observability

---

## 3.6 Validation Plugins (Specialization, NOT NEW BASE)

Validation is **semantic**, not structural.

```java
public interface ModelValidationPlugin extends InferencePhasePlugin {

    default InferencePhase phase() {
        return InferencePhase.MODEL_VALIDATION;
    }

    void validate(InferenceContext context, EngineContext engineContext);

    @Override
    default void execute(InferenceContext context, EngineContext engineContext) {
        validate(context, engineContext);
    }
}
```

‚úî No extra lifecycle
‚úî Still a phase plugin
‚úî Still configurable

---

## 3.7 Example Plugin (Concrete)

### TokenLimitValidationPlugin

```java
public final class TokenLimitValidationPlugin
        implements ModelValidationPlugin {

    private int maxTokens;

    @Override
    public String id() {
        return "token-limit-validator";
    }

    @Override
    public int order() {
        return 10;
    }

    @Override
    public void configure(Configuration configuration) {
        this.maxTokens = configuration.getInt("maxTokens", 4096);
    }

    @Override
    public void validate(
            InferenceContext context,
            EngineContext engineContext
    ) {
        int requested = (int) context
                .request()
                .parameters()
                .getOrDefault("maxTokens", 0);

        if (requested > maxTokens) {
            throw new IllegalStateException(
                    "Token limit exceeded"
            );
        }
    }
}
```

---

## 3.8 PluginRegistry (ENGINE-LEVEL)

**Purpose:**
Central authority for plugin management.

```java
public interface PluginRegistry {

    Collection<InferencePhasePlugin> phasePlugins();

    Optional<InferencePhasePlugin> find(String id);
}
```

### Default Implementation

```java
public final class DefaultPluginRegistry
        implements PluginRegistry {

    private final Map<String, InferencePhasePlugin> plugins;

    public DefaultPluginRegistry(
            Collection<InferencePhasePlugin> plugins
    ) {
        this.plugins = plugins.stream()
                .collect(Collectors.toUnmodifiableMap(
                        Plugin::id,
                        p -> p
                ));
    }

    @Override
    public Collection<InferencePhasePlugin> phasePlugins() {
        return plugins.values();
    }

    @Override
    public Optional<InferencePhasePlugin> find(String id) {
        return Optional.ofNullable(plugins.get(id));
    }
}
```

---

## üß† STEP 3 CHECKPOINT (Mental Model)

You now have:

```
Plugin
 ‚îî‚îÄ‚îÄ ConfigurablePlugin
       ‚îî‚îÄ‚îÄ InferencePhasePlugin
             ‚îî‚îÄ‚îÄ ModelValidationPlugin
```

And:

```
PluginRegistry
PipelineCompiler
InferencePipeline
InferencePhase
```

Still **no executor**, **no provider**, **no runtime**.
This is intentional.

---

## ‚ñ∂Ô∏è NEXT STEP (Step 4)

**EngineContext & Runtime Wiring**

We will:

* Lock `EngineContext`
* Show where your existing components fit
* Wire plugins, pipeline, executors cleanly

üëâ Say **‚Äúgo step 4‚Äù**
