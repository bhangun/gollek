Perfect.
We continue **without changing anything from Step 1**.

---

# ‚úÖ STEP 2 ‚Äî INFERENCE PHASE & PIPELINE

*(Determinism, Ordering, Governance)*

This step answers **one critical question**:

> **When** does something happen in the engine?

Not *how* and not *who* ‚Äî only **when**.

---

## 2.1 InferencePhase (LOCKED ENUM)

**Purpose:**
Defines the **semantic lifecycle** of inference.

> Plugins attach to phases
> Phases never depend on plugins

```java
public enum InferencePhase {

    /**
     * Input normalization, defaults, enrichment
     */
    PRE_VALIDATION,

    /**
     * Model allowlist, quota, jurisdiction, safety
     */
    MODEL_VALIDATION,

    /**
     * Prompt shaping, routing, context injection
     */
    PRE_INFERENCE,

    /**
     * The actual model / tool execution
     */
    INFERENCE,

    /**
     * Result inspection, redaction, moderation
     */
    POST_INFERENCE,

    /**
     * Formatting, transformation, aggregation
     */
    POST_PROCESSING,

    /**
     * Metrics, tracing, billing, audit
     */
    OBSERVABILITY,

    /**
     * Cleanup, persistence, async side-effects
     */
    CLEANUP
}
```

### ‚ùó Design Guarantees

* Order is **deterministic**
* Phases are **non-optional**
* No custom phases per plugin (enterprise safety)

---

## 2.2 Why Phases ‚â† Plugins (IMPORTANT)

| Concept            | Responsibility               |
| ------------------ | ---------------------------- |
| **InferencePhase** | WHEN something runs          |
| **Plugin**         | WHAT logic runs              |
| **Pipeline**       | WHICH plugins in which phase |

This avoids:

* Phase explosion
* Plugin coupling
* Runtime chaos

---

## 2.3 InferencePipeline

**Purpose:**
A **compiled execution plan** ‚Äî immutable, auditable, cacheable.

```java
public final class InferencePipeline {

    private final Map<InferencePhase, List<InferencePhasePlugin>> phases;

    public InferencePipeline(
            Map<InferencePhase, List<InferencePhasePlugin>> phases
    ) {
        this.phases = Map.copyOf(phases);
    }

    public List<InferencePhasePlugin> plugins(InferencePhase phase) {
        return phases.getOrDefault(phase, List.of());
    }

    public Set<InferencePhase> definedPhases() {
        return phases.keySet();
    }
}
```

‚úî Built once
‚úî Used many times
‚úî Safe for concurrency

---

## 2.4 Phase Ordering Contract

**Purpose:**
Guarantee execution order **even across runtimes**.

```java
public final class PhaseOrder {

    private PhaseOrder() {}

    public static List<InferencePhase> ordered() {
        return List.of(
                InferencePhase.PRE_VALIDATION,
                InferencePhase.MODEL_VALIDATION,
                InferencePhase.PRE_INFERENCE,
                InferencePhase.INFERENCE,
                InferencePhase.POST_INFERENCE,
                InferencePhase.POST_PROCESSING,
                InferencePhase.OBSERVABILITY,
                InferencePhase.CLEANUP
        );
    }
}
```

‚ö†Ô∏è This list is the **engine law**
Never dynamically reordered

---

## 2.5 PipelineCompiler (VERY IMPORTANT)

**Purpose:**
Turns **plugins + config** into an executable pipeline.

```java
public final class PipelineCompiler {

    public InferencePipeline compile(
            Collection<InferencePhasePlugin> plugins
    ) {
        Map<InferencePhase, List<InferencePhasePlugin>> map =
                new EnumMap<>(InferencePhase.class);

        for (InferencePhase phase : InferencePhase.values()) {
            map.put(phase, new ArrayList<>());
        }

        for (InferencePhasePlugin plugin : plugins) {
            map.get(plugin.phase()).add(plugin);
        }

        // Deterministic ordering inside each phase
        for (List<InferencePhasePlugin> list : map.values()) {
            list.sort(Comparator.comparingInt(InferencePhasePlugin::order));
        }

        return new InferencePipeline(map);
    }
}
```

‚úî No runtime logic
‚úî No context
‚úî Pure compilation

---

## 2.6 What Happens in Each Phase (Semantic Contract)

| Phase            | Allowed Actions           |
| ---------------- | ------------------------- |
| PRE_VALIDATION   | normalize input, defaults |
| MODEL_VALIDATION | allow/deny execution      |
| PRE_INFERENCE    | build prompt, route model |
| INFERENCE        | **ONLY executor runs**    |
| POST_INFERENCE   | moderation, inspection    |
| POST_PROCESSING  | transform result          |
| OBSERVABILITY    | emit events/metrics       |
| CLEANUP          | persistence, async        |

‚ö†Ô∏è **Executors run ONLY in `INFERENCE`**

---

## üß† STEP 2 CHECKPOINT (Mental Model)

You now have:

```
InferencePipeline
 ‚îú‚îÄ‚îÄ PRE_VALIDATION       -> plugins[]
 ‚îú‚îÄ‚îÄ MODEL_VALIDATION    -> plugins[]
 ‚îú‚îÄ‚îÄ PRE_INFERENCE       -> plugins[]
 ‚îú‚îÄ‚îÄ INFERENCE           -> executor
 ‚îú‚îÄ‚îÄ POST_INFERENCE      -> plugins[]
 ‚îú‚îÄ‚îÄ POST_PROCESSING     -> plugins[]
 ‚îú‚îÄ‚îÄ OBSERVABILITY       -> plugins[]
 ‚îî‚îÄ‚îÄ CLEANUP              -> plugins[]
```

No providers
No runtime
No orchestration yet

This is **correct layering**.

---

## ‚ñ∂Ô∏è NEXT STEP (Step 3)

**Plugin System ‚Äî Final & Canonical**

We will implement:

* `Plugin`
* `ConfigurablePlugin`
* `InferencePhasePlugin`
* Lifecycle rules
* Failure semantics

üëâ Say **‚Äúgo step 3‚Äù**
