Alright â€” continuing **next step** in a **clean, consistent, engine-level progression**, without contradicting earlier abstractions.

Up to now, we implicitly covered:

1. **Core Engine Contracts**
2. **Plugin System & Lifecycle**
3. **Execution Model (standalone + distributed)**
4. **Executor Dispatching**

---

# ğŸ”¹ Step 5 â€” Engine Context Wiring (The Missing Spine)

This step answers your **explicit question**:

> *â€œwhere to put / implement these in the engine module?â€*
> (`EventPublisher`, `Configuration`, `PersistenceProvider`, `ExecutorDispatcher`, `SecurityContext`, `ExecutorClientFactory`, etc.)

---

## 5.1 Engine Module Responsibility (Non-Negotiable)

The **engine module** must contain:

âœ… **Interfaces (contracts)**
âœ… **Default implementations (safe + minimal)**
âŒ No infra coupling (Kafka, DB, HTTP clients stay outside)

Think of the engine as **kernel + SPI**, not runtime.

---

## 5.2 Final Engine Package Layout (Best Practice)

```
engine/
â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ EngineContext.java
â”‚   â”œâ”€â”€ WorkflowEngine.java
â”‚   â”œâ”€â”€ ExecutionContext.java
â”‚
â”œâ”€â”€ execution/
â”‚   â”œâ”€â”€ ExecutorDispatcher.java
â”‚   â”œâ”€â”€ ExecutorClient.java
â”‚   â”œâ”€â”€ ExecutorClientFactory.java
â”‚
â”œâ”€â”€ event/
â”‚   â”œâ”€â”€ EventBus.java
â”‚   â”œâ”€â”€ EventPublisher.java
â”‚   â””â”€â”€ EngineEvent.java
â”‚
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ Configuration.java
â”‚   â””â”€â”€ ConfigProvider.java
â”‚
â”œâ”€â”€ persistence/
â”‚   â”œâ”€â”€ PersistenceProvider.java
â”‚   â””â”€â”€ ExecutionStateStore.java
â”‚
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ SecurityContext.java
â”‚   â””â”€â”€ Identity.java
â”‚
â”œâ”€â”€ plugin/
â”‚   â”œâ”€â”€ Plugin.java
â”‚   â”œâ”€â”€ PluginRegistry.java
â”‚   â””â”€â”€ PluginContext.java
â”‚
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ DefaultEngineContext.java
â”‚   â”œâ”€â”€ ServiceRegistry.java
â”‚   â””â”€â”€ ClockProvider.java
â”‚
â””â”€â”€ EngineBootstrap.java
```

---

## 5.3 EngineContext (Final, Correct, Stable)

Your interface is **correct** â€” no changes needed:

```java
public interface EngineContext {

    Clock clock();

    PluginRegistry pluginRegistry();

    ExecutorDispatcher executorDispatcher();

    EventBus eventBus();

    EventPublisher eventPublisher();

    PersistenceProvider persistence();

    SecurityContext security();

    Configuration configuration();

    ExecutorClientFactory executorClientFactory();

    <T> T getService(Class<T> type);

    Map<String, Object> attributes();
}
```

âš ï¸ **Important rule**
`EngineContext` is **read-only** for executors and plugins.

---

## 5.4 DefaultEngineContext (Kernel Implementation)

```java
public final class DefaultEngineContext implements EngineContext {

    private final Clock clock;
    private final PluginRegistry pluginRegistry;
    private final ExecutorDispatcher executorDispatcher;
    private final EventBus eventBus;
    private final EventPublisher eventPublisher;
    private final PersistenceProvider persistence;
    private final SecurityContext security;
    private final Configuration configuration;
    private final ExecutorClientFactory executorClientFactory;
    private final ServiceRegistry services;
    private final Map<String, Object> attributes = new ConcurrentHashMap<>();

    public DefaultEngineContext(
        Clock clock,
        PluginRegistry pluginRegistry,
        ExecutorDispatcher executorDispatcher,
        EventBus eventBus,
        EventPublisher eventPublisher,
        PersistenceProvider persistence,
        SecurityContext security,
        Configuration configuration,
        ExecutorClientFactory executorClientFactory,
        ServiceRegistry services
    ) {
        this.clock = clock;
        this.pluginRegistry = pluginRegistry;
        this.executorDispatcher = executorDispatcher;
        this.eventBus = eventBus;
        this.eventPublisher = eventPublisher;
        this.persistence = persistence;
        this.security = security;
        this.configuration = configuration;
        this.executorClientFactory = executorClientFactory;
        this.services = services;
    }

    @Override public Clock clock() { return clock; }
    @Override public PluginRegistry pluginRegistry() { return pluginRegistry; }
    @Override public ExecutorDispatcher executorDispatcher() { return executorDispatcher; }
    @Override public EventBus eventBus() { return eventBus; }
    @Override public EventPublisher eventPublisher() { return eventPublisher; }
    @Override public PersistenceProvider persistence() { return persistence; }
    @Override public SecurityContext security() { return security; }
    @Override public Configuration configuration() { return configuration; }
    @Override public ExecutorClientFactory executorClientFactory() { return executorClientFactory; }

    @Override
    public <T> T getService(Class<T> type) {
        return services.get(type);
    }

    @Override
    public Map<String, Object> attributes() {
        return attributes;
    }
}
```

---

## 5.5 ExecutorDispatcher (Local vs Distributed)

```java
public interface ExecutorDispatcher {

    ExecutionResult dispatch(
        ExecutionContext context,
        ExecutorDescriptor executor,
        ExecutionToken token
    );
}
```

### Default Routing Logic

```java
public final class DefaultExecutorDispatcher implements ExecutorDispatcher {

    private final ExecutorClientFactory clientFactory;

    public DefaultExecutorDispatcher(ExecutorClientFactory clientFactory) {
        this.clientFactory = clientFactory;
    }

    @Override
    public ExecutionResult dispatch(
        ExecutionContext context,
        ExecutorDescriptor executor,
        ExecutionToken token
    ) {
        ExecutorClient client = clientFactory.getClient(executor);
        return client.execute(context, executor, token);
    }
}
```

âœ”ï¸ Works for:

* Embedded
* Remote
* Agent
* ACP / MCP executors

---

## 5.6 PersistenceProvider (Engine-Owned)

```java
public interface PersistenceProvider {

    ExecutionStateStore executionStates();

    PluginStateStore pluginStates();
}
```

âš ï¸ Rule:

* Engine **defines**
* Runtime **implements** (JPA, Redis, S3, EventStore, etc.)

---

## 5.7 SecurityContext (Policy-Agnostic)

```java
public interface SecurityContext {

    Identity identity();

    boolean hasPermission(String permission);

    Map<String, Object> attributes();
}
```

This allows:

* RBAC
* ABAC
* Policy engines
* Human approval flows

---

## 5.8 EventPublisher vs EventBus (You Were Right)

| Component        | Purpose                 |
| ---------------- | ----------------------- |
| `EventPublisher` | Engine â†’ external world |
| `EventBus`       | Internal decoupling     |

```java
public interface EventPublisher {
    void publish(EngineEvent event);
}
```

âœ”ï¸ Enables:

* Auditing
* Observability
* Control-plane sync

---

## 5.9 Configuration (Immutable Snapshot)

```java
public interface Configuration {

    String getString(String key);

    Integer getInt(String key);

    Boolean getBoolean(String key);

    <T> T get(String key, Class<T> type);
}
```

âš ï¸ Configuration is **compiled**, not mutable at runtime.

---

## 5.10 Why This Design Is Correct

This engine can now power:

âœ” Low-code workflow
âœ” Agentic AI (ACP / MCP / A2A)
âœ” ESB-style integrations
âœ” BPMN-like automation
âœ” Kong-class gateways
âœ” On-prem or cloud

And **nothing is duplicated**.

---

## Next Step (Step 6)

ğŸ‘‰ **Execution Lifecycle & State Machine**

* Deterministic retries
* Compensation
* Partial execution
* Human-in-the-loop
* Long-running agent negotiations

Say **â€œgo step 6â€** and Iâ€™ll continue.
