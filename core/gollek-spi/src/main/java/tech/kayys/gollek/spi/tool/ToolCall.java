package tech.kayys.gollek.spi.tool;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * Represents a tool call generated by the model.
 */
public final class ToolCall {

    @NotBlank
    private final String id;

    @NotNull
    private final ToolDefinition.Type type;

    @NotNull
    private final Function function;

    @NotBlank
    private final String name;

    private final Map<String, Object> arguments;

    @JsonCreator
    public ToolCall(
            @JsonProperty("id") String id,
            @JsonProperty("name") String name,
            @JsonProperty("function") Function function,
            @JsonProperty("arguments") Map<String, Object> arguments,
            @JsonProperty("type") ToolDefinition.Type type) {
        this.id = Objects.requireNonNull(id, "id");
        this.name = Objects.requireNonNull(name, "name");
        this.arguments = arguments != null
                ? Collections.unmodifiableMap(new HashMap<>(arguments))
                : Collections.emptyMap();
        this.type = Objects.requireNonNull(type, "type");
        this.function = Objects.requireNonNull(function, "function");
    }

    // Constructor that matches the expected signature from the error: (String,
    // String, Map<String,Object>, String)
    public ToolCall(String id, String name, Map<String, Object> arguments, String type) {
        this.id = Objects.requireNonNull(id, "id");
        this.name = Objects.requireNonNull(name, "name");
        this.arguments = arguments != null
                ? Collections.unmodifiableMap(new HashMap<>(arguments))
                : Collections.emptyMap();
        this.type = "function".equalsIgnoreCase(type) ? ToolDefinition.Type.FUNCTION : ToolDefinition.Type.FUNCTION; // Default
                                                                                                                     // to
                                                                                                                     // FUNCTION
        this.function = new Function(name, arguments != null ? arguments.toString() : "{}"); // Create function with
                                                                                             // name and arguments
    }

    public String getId() {
        return id;
    }

    public ToolDefinition.Type getType() {
        return type;
    }

    public Map<String, Object> getArguments() {
        return arguments;
    }

    public Function getFunction() {
        return function;
    }

    public static class Function {
        private final String name;
        private final String arguments;

        @JsonCreator
        public Function(
                @JsonProperty("name") String name,
                @JsonProperty("arguments") String arguments) {
            this.name = name;
            this.arguments = arguments;
        }

        public String getName() {
            return name;
        }

        public String getArguments() {
            return arguments;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            Function function = (Function) o;
            return Objects.equals(name, function.name) && Objects.equals(arguments, function.arguments);
        }

        @Override
        public int hashCode() {
            return Objects.hash(name, arguments);
        }
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private String id;
        private String name;
        private final Map<String, Object> arguments = new HashMap<>();
        private String type = "function";

        public Builder id(String id) {
            this.id = id;
            return this;
        }

        public Builder name(String name) {
            this.name = name;
            return this;
        }

        public Builder arguments(Map<String, Object> arguments) {
            this.arguments.putAll(arguments);
            return this;
        }

        public Builder argument(String key, Object value) {
            this.arguments.put(key, value);
            return this;
        }

        public Builder type(String type) {
            this.type = type;
            return this;
        }

        public ToolCall build() {
            Objects.requireNonNull(name, "name is required");
            if (id == null) {
                id = "call_" + System.currentTimeMillis();
            }

            // Create a Function object for the ToolCall
            Function functionObj = new Function(name, arguments != null ? arguments.toString() : "{}");

            // Determine the Tool.Type from the string
            ToolDefinition.Type toolType = "function".equalsIgnoreCase(type) ? ToolDefinition.Type.FUNCTION
                    : ToolDefinition.Type.FUNCTION; // Default
            // to
            // FUNCTION

            return new ToolCall(id, name, functionObj, arguments, toolType);
        }
    }

    @Override
    public String toString() {
        return "ToolCall{" +
                "id='" + id + '\'' +
                ", name='" + name + '\'' +
                ", type='" + type + '\'' +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        ToolCall toolCall = (ToolCall) o;
        return Objects.equals(id, toolCall.id) && type == toolCall.type && Objects.equals(function, toolCall.function);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, type, function);
    }
}
